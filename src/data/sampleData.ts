import { Topic, Lesson, Question } from '../types';

// Complete Topics based on Dasar Pemrograman Rust structure (A.1 - A.55)
export const sampleTopics: Topic[] = [
  {
    id: 'fundamentals',
    title: 'Rust Fundamentals',
    description: 'Master the basics: Hello World, build tools, comments, and variables',
    order: 1,
    lessons: ['hello-rust', 'build-run', 'comments', 'variables', 'data-types-scalar'],
  },
  {
    id: 'data-types',
    title: 'Data Types & Constants',
    description: 'Understanding Rust\'s type system, strings, constants, and operators',
    order: 2,
    lessons: ['string-literals', 'constants', 'operators', 'type-alias-casting'],
  },
  {
    id: 'control-structures',
    title: 'Control Structures',
    description: 'Master conditionals, loops, and control flow patterns',
    order: 3,
    lessons: ['conditionals', 'while-loops', 'loop-break-continue', 'for-loops'],
  },
  {
    id: 'collections',
    title: 'Collections & Data Structures',
    description: 'Arrays, slices, tuples, vectors, and basic data organization',
    order: 4,
    lessons: ['arrays', 'slices-basic', 'tuples', 'vectors'],
  },
  {
    id: 'functions-modules',
    title: 'Functions & Module System',
    description: 'Function definitions and comprehensive module organization',
    order: 5,
    lessons: ['functions', 'module-path-item', 'package-crate', 'modules', 'inline-modules', 'scope-access'],
  },
  {
    id: 'structs-enums',
    title: 'Structs & Enums',
    description: 'Custom types, associated functions, methods, and enumerations',
    order: 6,
    lessons: ['structs', 'associated-functions', 'methods', 'enums'],
  },
  {
    id: 'module-system-advanced',
    title: 'Advanced Module System',
    description: 'Visibility, privacy, imports, and code organization patterns',
    order: 7,
    lessons: ['visibility-privacy', 'use-import-reexport', 'block-expressions', 'shadowing'],
  },
  {
    id: 'memory-management',
    title: 'Memory Management',
    description: 'Understanding Rust\'s memory model, pointers, and ownership',
    order: 8,
    lessons: ['basic-memory-management', 'pointers-references', 'ownership', 'borrowing'],
  },
  {
    id: 'traits-generics',
    title: 'Traits & Generics',
    description: 'Define behavior with traits and write generic, reusable code',
    order: 9,
    lessons: ['traits', 'traits-advanced', 'generics'],
  },
  {
    id: 'advanced-types',
    title: 'Advanced Types & Patterns',
    description: 'Option, Result, error handling, and pattern matching',
    order: 10,
    lessons: ['option-type', 'result-type', 'question-operator', 'pattern-matching'],
  },
  {
    id: 'advanced-concepts',
    title: 'Advanced Concepts',
    description: 'Static items, lifetimes, and advanced memory management',
    order: 11,
    lessons: ['static-items', 'lifetimes', 'slice-memory-management'],
  },
  {
    id: 'strings-advanced',
    title: 'String Management',
    description: 'Deep dive into string types and string manipulation',
    order: 12,
    lessons: ['string-literal-vs-string', 'string-custom-type'],
  },
  {
    id: 'functional-programming',
    title: 'Functional Programming',
    description: 'Closures, function traits, and iterator patterns',
    order: 13,
    lessons: ['closures', 'function-traits', 'iterator-trait'],
  },
  {
    id: 'system-programming',
    title: 'System Programming',
    description: 'Attributes, date/time, file system operations',
    order: 14,
    lessons: ['attributes', 'date-time', 'file-path-directory'],
  },
  {
    id: 'error-handling',
    title: 'Error Handling',
    description: 'Comprehensive error handling with panic and recoverable errors',
    order: 15,
    lessons: ['unrecoverable-errors', 'recoverable-errors'],
  },
];

// Complete Lessons following A.1 - A.55 structure
export const sampleLessons: Lesson[] = [
  // Fundamentals (A.1 - A.5)
  {
    id: 'hello-rust',
    title: 'A.1. Program Pertama ➜ Hello Rust',
    topicId: 'fundamentals',
    summary: 'Write your first Rust program and understand the basic syntax. Learn about the main function, printing to console, and compiling Rust code.',
    questions: ['hello-q1', 'hello-q2', 'hello-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.1-program-pertama',
    order: 1,
  },
  {
    id: 'build-run',
    title: 'A.2. Build dan Run Program Rust',
    topicId: 'fundamentals',
    summary: 'Learn how to compile and run Rust programs using rustc and cargo. Understand the difference between compilation and execution.',
    questions: ['build-q1', 'build-q2', 'build-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.2-build-dan-run-program-rust',
    order: 2,
  },
  {
    id: 'comments',
    title: 'A.3. Komentar',
    topicId: 'fundamentals',
    summary: 'Learn different types of comments in Rust: line comments, block comments, and documentation comments.',
    questions: ['comment-q1', 'comment-q2'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.3-komentar',
    order: 3,
  },
  {
    id: 'variables',
    title: 'A.4. Variabel',
    topicId: 'fundamentals',
    summary: 'Understand Rust variables, mutability, and variable declaration patterns.',
    questions: ['vars-q1', 'vars-q2', 'vars-q3', 'vars-q4'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.4-variabel',
    order: 4,
  },
  {
    id: 'data-types-scalar',
    title: 'A.5. Tipe Data ➜ Primitive Scalar',
    topicId: 'fundamentals',
    summary: 'Master primitive scalar data types: integers, floats, booleans, and characters.',
    questions: ['scalar-q1', 'scalar-q2', 'scalar-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.5-tipe-data-primitive-scalar',
    order: 5,
  },

  // Data Types & Constants (A.6 - A.8, A.27)
  {
    id: 'string-literals',
    title: 'A.6. Tipe Data ➜ String Literal (&str)',
    topicId: 'data-types',
    summary: 'Understanding string literals, string slices, and basic string operations.',
    questions: ['str-q1', 'str-q2', 'str-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.6-tipe-data-string-literal',
    order: 1,
  },
  {
    id: 'constants',
    title: 'A.7. Konstanta',
    topicId: 'data-types',
    summary: 'Learn about constants, static variables, and compile-time evaluation.',
    questions: ['const-q1', 'const-q2'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.7-konstanta',
    order: 2,
  },
  {
    id: 'operators',
    title: 'A.8. Operator',
    topicId: 'data-types',
    summary: 'Master arithmetic, comparison, logical, and bitwise operators in Rust.',
    questions: ['op-q1', 'op-q2', 'op-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.8-operator',
    order: 3,
  },
  {
    id: 'type-alias-casting',
    title: 'A.27. Type Alias & Casting',
    topicId: 'data-types',
    summary: 'Learn type aliases for better code readability and type casting between different types.',
    questions: ['alias-q1', 'cast-q1', 'cast-q2'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.27-type-alias-casting',
    order: 4,
  },

  // Control Structures (A.9 - A.12)
  {
    id: 'conditionals',
    title: 'A.9. Seleksi Kondisi ➜ if, else if, else',
    topicId: 'control-structures',
    summary: 'Learn conditional statements in Rust. Understand how to use if, else if, and else for decision making.',
    questions: ['cond-q1', 'cond-q2', 'cond-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.9-seleksi-kondisi',
    order: 1,
  },
  {
    id: 'while-loops',
    title: 'A.10. Perulangan ➜ while',
    topicId: 'control-structures',
    summary: 'Master while loops for conditional iteration and understand loop control.',
    questions: ['while-q1', 'while-q2'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.10-perulangan-while',
    order: 2,
  },
  {
    id: 'loop-break-continue',
    title: 'A.11. Perulangan ➜ loop, break, continue, label',
    topicId: 'control-structures',
    summary: 'Understanding infinite loops with loop keyword, break, continue, and labeled loops.',
    questions: ['loop-q1', 'loop-q2', 'loop-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.11-perulangan-loop-break-continue-label',
    order: 3,
  },
  {
    id: 'for-loops',
    title: 'A.12. Perulangan ➜ for in',
    topicId: 'control-structures',
    summary: 'Learn for-in loops for iterating over collections and ranges.',
    questions: ['for-q1', 'for-q2', 'for-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.12-perulangan-for-in',
    order: 4,
  },

  // Collections (A.13 - A.16)
  {
    id: 'arrays',
    title: 'A.13. Array',
    topicId: 'collections',
    summary: 'Working with fixed-size arrays and understanding array syntax and operations.',
    questions: ['arr-q1', 'arr-q2', 'arr-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.13-array',
    order: 1,
  },
  {
    id: 'slices-basic',
    title: 'A.14. Slice (Basic)',
    topicId: 'collections',
    summary: 'Introduction to slices as views into arrays and basic slice operations.',
    questions: ['slice-q1', 'slice-q2'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.14-slice-basic',
    order: 2,
  },
  {
    id: 'tuples',
    title: 'A.15. Tuple',
    topicId: 'collections',
    summary: 'Understand tuples as a way to group values of different types together.',
    questions: ['tuple-q1', 'tuple-q2'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.15-tuple',
    order: 3,
  },
  {
    id: 'vectors',
    title: 'A.16. Vector',
    topicId: 'collections',
    summary: 'Working with dynamic arrays (Vec) for growable collections.',
    questions: ['vec-q1', 'vec-q2', 'vec-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.16-vector',
    order: 4,
  },

  // Functions & Module System (A.17 - A.22)
  {
    id: 'functions',
    title: 'A.17. Function',
    topicId: 'functions-modules',
    summary: 'Learn how to define and call functions in Rust. Understand parameters, return values, and function scope.',
    questions: ['func-q1', 'func-q2', 'func-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.17-function',
    order: 1,
  },
  {
    id: 'module-path-item',
    title: 'A.18. Module System ➜ Path & Item',
    topicId: 'functions-modules',
    summary: 'Understanding module paths, items, and how Rust organizes code.',
    questions: ['path-q1', 'path-q2'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.18-module-system-path-item',
    order: 2,
  },
  {
    id: 'package-crate',
    title: 'A.19. Module System ➜ Package & Crate',
    topicId: 'functions-modules',
    summary: 'Learn about packages, crates, and the Rust compilation units.',
    questions: ['pkg-q1', 'crate-q1'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.19-module-system-package-crate',
    order: 3,
  },
  {
    id: 'modules',
    title: 'A.20. Module System ➜ Module',
    topicId: 'functions-modules',
    summary: 'Creating and organizing modules for better code structure.',
    questions: ['mod-q1', 'mod-q2'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.20-module-system-module',
    order: 4,
  },
  {
    id: 'inline-modules',
    title: 'A.21. Module System ➜ Inline Module',
    topicId: 'functions-modules',
    summary: 'Working with inline modules and nested module structures.',
    questions: ['inline-q1', 'inline-q2'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.21-module-system-inline-module',
    order: 5,
  },
  {
    id: 'scope-access',
    title: 'A.22. Module System ➜ Scope & Akses Item',
    topicId: 'functions-modules',
    summary: 'Understanding scope rules and item accessibility in modules.',
    questions: ['scope-q1', 'access-q1'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.22-module-system-scope-akses-item',
    order: 6,
  },

  // Structs & Enums (A.23 - A.26)
  {
    id: 'structs',
    title: 'A.23. Struct',
    topicId: 'structs-enums',
    summary: 'Create custom data types using structs. Learn how to define structs, create instances, and access fields.',
    questions: ['struct-q1', 'struct-q2', 'struct-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.23-struct',
    order: 1,
  },
  {
    id: 'associated-functions',
    title: 'A.24. Associated Function',
    topicId: 'structs-enums',
    summary: 'Learn about associated functions and how they differ from methods.',
    questions: ['assoc-q1', 'assoc-q2'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.24-associated-function',
    order: 2,
  },
  {
    id: 'methods',
    title: 'A.25. Method',
    topicId: 'structs-enums',
    summary: 'Define methods on structs and understand self, &self, and &mut self.',
    questions: ['method-q1', 'method-q2', 'method-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.25-method',
    order: 3,
  },
  {
    id: 'enums',
    title: 'A.26. Enum',
    topicId: 'structs-enums',
    summary: 'Define enums to represent data that can be one of several possible variants.',
    questions: ['enum-q1', 'enum-q2', 'enum-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.26-enum',
    order: 4,
  },

  // Advanced Module System (A.28 - A.31)
  {
    id: 'visibility-privacy',
    title: 'A.28. Module System ➜ Visibility & Privacy',
    topicId: 'module-system-advanced',
    summary: 'Understanding pub keyword, privacy rules, and visibility modifiers.',
    questions: ['vis-q1', 'priv-q1', 'priv-q2'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.28-module-system-visibility-privacy',
    order: 1,
  },
  {
    id: 'use-import-reexport',
    title: 'A.29. Module System ➜ Use, Import, Re-export',
    topicId: 'module-system-advanced',
    summary: 'Master use statements, importing items, and re-exporting functionality.',
    questions: ['use-q1', 'use-q2', 'reexp-q1'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.29-module-system-use-import-re-export',
    order: 2,
  },
  {
    id: 'block-expressions',
    title: 'A.30. Block Expression',
    topicId: 'module-system-advanced',
    summary: 'Understanding block expressions and how they return values.',
    questions: ['block-q1', 'block-q2'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.30-block-expression',
    order: 3,
  },
  {
    id: 'shadowing',
    title: 'A.31. Shadowing',
    topicId: 'module-system-advanced',
    summary: 'Learn about variable shadowing and when to use it effectively.',
    questions: ['shadow-q1', 'shadow-q2'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.31-shadowing',
    order: 4,
  },

  // Memory Management (A.32 - A.35)
  {
    id: 'basic-memory-management',
    title: 'A.32. Basic Memory Management',
    topicId: 'memory-management',
    summary: 'Understanding stack vs heap, memory allocation, and Rust\'s memory model.',
    questions: ['mem-q1', 'mem-q2', 'mem-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.32-basic-memory-management',
    order: 1,
  },
  {
    id: 'pointers-references',
    title: 'A.33. Pointer & References',
    topicId: 'memory-management',
    summary: 'Learn about references, dereferencing, and pointer concepts in Rust.',
    questions: ['ptr-q1', 'ref-q1', 'ref-q2'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.33-pointer-references',
    order: 2,
  },
  {
    id: 'ownership',
    title: 'A.34. Ownership',
    topicId: 'memory-management',
    summary: 'Master Rust\'s ownership system, moves, and ownership rules.',
    questions: ['own-q1', 'own-q2', 'own-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.34-ownership',
    order: 3,
  },
  {
    id: 'borrowing',
    title: 'A.35. Borrowing',
    topicId: 'memory-management',
    summary: 'Understand borrowing rules, mutable and immutable references.',
    questions: ['borrow-q1', 'borrow-q2', 'borrow-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.35-borrowing',
    order: 4,
  },

  // Traits & Generics (A.36 - A.38)
  {
    id: 'traits',
    title: 'A.36. Traits',
    topicId: 'traits-generics',
    summary: 'Define shared behavior using traits, similar to interfaces in other languages.',
    questions: ['trait-q1', 'trait-q2', 'trait-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.36-traits',
    order: 1,
  },
  {
    id: 'traits-advanced',
    title: 'A.37. Traits ➜ Advanced',
    topicId: 'traits-generics',
    summary: 'Advanced trait features: associated types, trait bounds, and trait objects.',
    questions: ['adv-trait-q1', 'adv-trait-q2', 'adv-trait-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.37-traits-advanced',
    order: 2,
  },
  {
    id: 'generics',
    title: 'A.38. Generics',
    topicId: 'traits-generics',
    summary: 'Write flexible and reusable code using generic type parameters.',
    questions: ['gen-q1', 'gen-q2', 'gen-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.38-generics',
    order: 3,
  },

  // Advanced Types & Patterns (A.39 - A.42)
  {
    id: 'option-type',
    title: 'A.39. Tipe Data ➜ Option',
    topicId: 'advanced-types',
    summary: 'Handle nullable values with Option type and understand Some/None patterns.',
    questions: ['opt-q1', 'opt-q2', 'opt-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.39-tipe-data-option',
    order: 1,
  },
  {
    id: 'result-type',
    title: 'A.40. Tipe Data ➜ Result',
    topicId: 'advanced-types',
    summary: 'Handle recoverable errors with Result type and understand Ok/Err patterns.',
    questions: ['res-q1', 'res-q2', 'res-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.40-tipe-data-result',
    order: 2,
  },
  {
    id: 'question-operator',
    title: 'A.41. Operator ?',
    topicId: 'advanced-types',
    summary: 'Master the ? operator for elegant error propagation and handling.',
    questions: ['quest-q1', 'quest-q2', 'quest-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.41-operator-question-mark',
    order: 3,
  },
  {
    id: 'pattern-matching',
    title: 'A.42. Pattern Matching',
    topicId: 'advanced-types',
    summary: 'Use match expressions and patterns to handle different cases and destructure data.',
    questions: ['match-q1', 'match-q2', 'match-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.42-pattern-matching',
    order: 4,
  },

  // Advanced Concepts (A.43 - A.45)
  {
    id: 'static-items',
    title: 'A.43. Static Item',
    topicId: 'advanced-concepts',
    summary: 'Understanding static variables, static lifetimes, and global state.',
    questions: ['static-q1', 'static-q2'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.43-static-item',
    order: 1,
  },
  {
    id: 'lifetimes',
    title: 'A.44. Lifetime',
    topicId: 'advanced-concepts',
    summary: 'Understand lifetime annotations and how Rust ensures references are valid.',
    questions: ['life-q1', 'life-q2', 'life-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.44-lifetime',
    order: 2,
  },
  {
    id: 'slice-memory-management',
    title: 'A.45. Slice Memory Management',
    topicId: 'advanced-concepts',
    summary: 'Deep dive into slice memory layout and advanced slice operations.',
    questions: ['slice-adv-q1', 'slice-adv-q2'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.45-slice-memory-management',
    order: 3,
  },

  // String Management (A.46 - A.47)
  {
    id: 'string-literal-vs-string',
    title: 'A.46. String Literal (&str) vs. String Custom Type',
    topicId: 'strings-advanced',
    summary: 'Understanding the difference between string literals and String type.',
    questions: ['str-vs-q1', 'str-vs-q2', 'str-vs-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.46-string-literal-vs-string-custom-type',
    order: 1,
  },
  {
    id: 'string-custom-type',
    title: 'A.47. Tipe Data ➜ String Custom Type',
    topicId: 'strings-advanced',
    summary: 'Working with String type: creation, manipulation, and memory management.',
    questions: ['string-type-q1', 'string-type-q2', 'string-type-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.47-tipe-data-string-custom-type',
    order: 2,
  },

  // Functional Programming (A.48 - A.50)
  {
    id: 'closures',
    title: 'A.48. Closures',
    topicId: 'functional-programming',
    summary: 'Create anonymous functions that can capture values from their environment.',
    questions: ['clos-q1', 'clos-q2', 'clos-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.48-closures',
    order: 1,
  },
  {
    id: 'function-traits',
    title: 'A.49. Trait ➜ Function (Fn, FnMut, FnOnce)',
    topicId: 'functional-programming',
    summary: 'Understanding function traits and how closures implement them.',
    questions: ['fn-trait-q1', 'fn-trait-q2', 'fn-trait-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.49-trait-function-fn-fnmut-fnonce',
    order: 2,
  },
  {
    id: 'iterator-trait',
    title: 'A.50. Trait ➜ Iterator',
    topicId: 'functional-programming',
    summary: 'Master the Iterator trait and functional programming patterns.',
    questions: ['iter-trait-q1', 'iter-trait-q2', 'iter-trait-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.50-trait-iterator',
    order: 3,
  },

  // System Programming (A.51 - A.53)
  {
    id: 'attributes',
    title: 'A.51. Attributes',
    topicId: 'system-programming',
    summary: 'Using attributes for metadata, conditional compilation, and code annotation.',
    questions: ['attr-q1', 'attr-q2'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.51-attributes',
    order: 1,
  },
  {
    id: 'date-time',
    title: 'A.52. Date Time',
    topicId: 'system-programming',
    summary: 'Working with dates, times, and duration in Rust applications.',
    questions: ['date-q1', 'time-q1', 'duration-q1'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.52-date-time',
    order: 2,
  },
  {
    id: 'file-path-directory',
    title: 'A.53. File, Path, Directory',
    topicId: 'system-programming',
    summary: 'File system operations: reading, writing files, and directory manipulation.',
    questions: ['file-q1', 'path-q1', 'dir-q1'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.53-file-path-directory',
    order: 3,
  },

  // Error Handling (A.54 - A.55)
  {
    id: 'unrecoverable-errors',
    title: 'A.54. Error ➜ Unrecoverable Error / Panic',
    topicId: 'error-handling',
    summary: 'Understanding panic, unrecoverable errors, and when to use them.',
    questions: ['panic-q1', 'panic-q2', 'panic-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.54-error-unrecoverable-error-panic',
    order: 1,
  },
  {
    id: 'recoverable-errors',
    title: 'A.55. Error ➜ Recoverable Error & Error Handling',
    topicId: 'error-handling',
    summary: 'Comprehensive error handling with Result, custom errors, and error propagation.',
    questions: ['err-handle-q1', 'err-handle-q2', 'err-handle-q3'],
    attributionUrl: 'https://dasarpemrogramanrust.novalagung.com/A.55-error-recoverable-error-error-handling',
    order: 2,
  },
];

// Sample subset of questions to start - full question set would be much larger
export const sampleQuestions: Question[] = [
  // Hello Rust questions (A.1)
  {
    id: 'hello-q1',
    type: 'mcq',
    prompt: 'What is the entry point of a Rust program?',
    choices: ['main()', 'start()', 'begin()', 'run()'],
    correctIndex: 0,
    explanation: 'The main() function is the entry point of every Rust program, just like in many other programming languages.',
    topicId: 'fundamentals',
    difficulty: 'beginner',
    points: 10,
  },
  {
    id: 'hello-q2',
    type: 'predict_output',
    prompt: 'What will this Rust code print?',
    code: 'fn main() {\n    println!("Hello, Rust!");\n}',
    expectedStdout: 'Hello, Rust!',
    explanation: 'The println! macro prints the text followed by a newline to the console.',
    topicId: 'fundamentals',
    difficulty: 'beginner',
    points: 10,
  },
  {
    id: 'hello-q3',
    type: 'fib',
    prompt: 'Complete the code to print "Welcome to Rust": println!("_____ to Rust");',
    acceptableAnswers: ['Welcome', 'welcome'],
    explanation: 'The println! macro is used to print text to the console in Rust.',
    topicId: 'fundamentals',
    difficulty: 'beginner',
    points: 10,
  },

  // Build and Run questions (A.2)
  {
    id: 'build-q1',
    type: 'mcq',
    prompt: 'Which command is used to compile a single Rust file?',
    choices: ['cargo build', 'rustc filename.rs', 'rust compile', 'cargo run'],
    correctIndex: 1,
    explanation: 'rustc is the Rust compiler that compiles individual .rs files directly.',
    topicId: 'fundamentals',
    difficulty: 'beginner',
    points: 10,
  },
  {
    id: 'build-q2',
    type: 'tf',
    prompt: 'Cargo is used for managing Rust projects and dependencies.',
    answer: true,
    explanation: 'Cargo is Rust\'s build system and package manager, used for project management and dependency handling.',
    topicId: 'fundamentals',
    difficulty: 'beginner',
    points: 10,
  },
  {
    id: 'build-q3',
    type: 'mcq',
    prompt: 'What does "cargo run" do?',
    choices: ['Only compiles the code', 'Only runs the code', 'Compiles and runs the code', 'Downloads dependencies'],
    correctIndex: 2,
    explanation: 'cargo run both compiles your Rust project and runs the resulting executable in one command.',
    topicId: 'fundamentals',
    difficulty: 'beginner',
    points: 10,
  },

  // Comments questions (A.3)
  {
    id: 'comment-q1',
    type: 'mcq',
    prompt: 'Which symbol is used for single-line comments in Rust?',
    choices: ['//', '/*', '#', '<!--'],
    correctIndex: 0,
    explanation: 'Double forward slashes (//) are used for single-line comments in Rust.',
    topicId: 'fundamentals',
    difficulty: 'beginner',
    points: 10,
  },
  {
    id: 'comment-q2',
    type: 'tf',
    prompt: 'Documentation comments in Rust start with three slashes (///).',
    answer: true,
    explanation: 'Triple slashes (///) are used for documentation comments that can be processed by rustdoc.',
    topicId: 'fundamentals',
    difficulty: 'beginner',
    points: 10,
  },

  // Variables questions (A.4)
  {
    id: 'vars-q1',
    type: 'mcq',
    prompt: 'How do you declare a mutable variable in Rust?',
    choices: ['let x = 5;', 'let mut x = 5;', 'var x = 5;', 'mutable x = 5;'],
    correctIndex: 1,
    explanation: 'In Rust, variables are immutable by default. Use "mut" keyword to make them mutable.',
    topicId: 'fundamentals',
    difficulty: 'beginner',
    points: 10,
  },
  {
    id: 'vars-q2',
    type: 'tf',
    prompt: 'In Rust, variables are mutable by default.',
    answer: false,
    explanation: 'In Rust, variables are immutable by default. You must explicitly use "mut" to make them mutable.',
    topicId: 'fundamentals',
    difficulty: 'beginner',
    points: 10,
  },
  {
    id: 'vars-q3',
    type: 'code_fix',
    prompt: 'Fix this code to make it compile:',
    code: 'let x = 5;\nx = 10;\nprintln!("{}", x);',
    choices: [
      'let mut x = 5;\nx = 10;\nprintln!("{}", x);',
      'let x = 5;\nlet x = 10;\nprintln!("{}", x);',
      'const x = 5;\nx = 10;\nprintln!("{}", x);',
      'var x = 5;\nx = 10;\nprintln!("{}", x);'
    ],
    correctIndex: 0,
    explanation: 'To modify a variable after declaration, it must be declared as mutable using the "mut" keyword.',
    topicId: 'fundamentals',
    difficulty: 'beginner',
    points: 10,
  },
  {
    id: 'vars-q4',
    type: 'predict_output',
    prompt: 'What will this code print?',
    code: 'let x = 5;\nlet x = x + 1;\nlet x = x * 2;\nprintln!("{}", x);',
    expectedStdout: '12',
    explanation: 'Variable shadowing allows redeclaring variables: x=5, then x=6, then x=12.',
    topicId: 'fundamentals',
    difficulty: 'beginner',
    points: 10,
  },

  // Scalar types questions (A.5)
  {
    id: 'scalar-q1',
    type: 'mcq',
    prompt: 'What is the default integer type in Rust?',
    choices: ['i8', 'i32', 'i64', 'u32'],
    correctIndex: 1,
    explanation: 'When no type is specified, Rust infers integer literals as i32 (32-bit signed integer) by default.',
    topicId: 'fundamentals',
    difficulty: 'beginner',
    points: 10,
  },
  {
    id: 'scalar-q2',
    type: 'tf',
    prompt: 'The char type in Rust can hold Unicode characters.',
    answer: true,
    explanation: 'Rust\'s char type is 4 bytes and can represent any Unicode scalar value.',
    topicId: 'fundamentals',
    difficulty: 'beginner',
    points: 10,
  },
  {
    id: 'scalar-q3',
    type: 'mcq',
    prompt: 'Which of these is NOT a valid boolean value in Rust?',
    choices: ['true', 'false', '1', '0'],
    correctIndex: 3,
    explanation: 'In Rust, boolean values are only true and false. Numbers like 0 and 1 are not boolean values.',
    topicId: 'fundamentals',
    difficulty: 'beginner',
    points: 10,
  },

  // Add more representative questions for other lessons...
  // For brevity, I'm including key examples. The full implementation would include 
  // comprehensive questions for all A.1-A.55 lessons.

  // Example advanced questions
  {
    id: 'life-q1',
    type: 'tf',
    prompt: 'Lifetime annotations change how long references live.',
    answer: false,
    explanation: 'Lifetime annotations don\'t change how long references live, they just tell Rust how the lifetimes relate to each other.',
    topicId: 'advanced-concepts',
    difficulty: 'intermediate',
    points: 15,
  },
  {
    id: 'err-handle-q1',
    type: 'mcq',
    prompt: 'Which operator is used for error propagation in Rust?',
    choices: ['?', '!', '&', '*'],
    correctIndex: 0,
    explanation: 'The ? operator automatically propagates errors, returning early if an error occurs.',
    topicId: 'error-handling',
    difficulty: 'intermediate',
    points: 15,
  },
];

export const sampleData = {
  topics: sampleTopics,
  lessons: sampleLessons,
  questions: sampleQuestions,
};